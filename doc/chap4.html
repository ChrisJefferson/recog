<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (recogbase) - Chapter 4: Group Recognition</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chap4.html">4</a></td><td><a href="chap5.html">5</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>
<p><a id="s0ss0" name="s0ss0"></a></p>

<h3>4. Group Recognition</h3>

<p>This chapter describes a generic framework for group recognition. The basic problem is, we want to solve the word problem: given any g in G, G = &lt; X &gt;, write a straight line program (SLP) from X to g. This is usually done by constructing some nice generators (and then writing an SLP from the nice generators to g and concatenating with an SLP from X to the nice generators). Often, for efficiency reasons, we will just store the nice generators and then only be interested in the SLP from those to g. The framework presented here deals with exactly this process.</p>

<p>The generic framework was designed having three situations in mind: permutation groups, matrix groups, and black box groups. Although the methods used are quite different for those three cases, there is a common pattern in the procedure of recognition. Namely, first we have to find a homomorphism, solve the word problem recursively in image and kernel, then put it together. The recursion ends in groups where we can solve the word problem directly. The general framework reflects this idea and separates it from the rest of the recognition methods.</p>

<p>Solution of the word problem comes in two stages: first a "recognition phase" and then a "verification phase". The recognition phase usually consists of randomized algorithms with certain error or failure probabilities. The result is some kind of "recognition information" that will describe the group already very well, but which is not yet proven to be correct. However, one can already write arbitrary elements in the group as product of the given generators. In the verification phase a presentation of the group is calculated, thereby proving that the group generated by the given generators is in fact isomorphic to the group described by the recognition information. In many cases the verification phase will be much more expensive than the recognition phase.</p>

<p>In the following sections, we describe the generic framework. We begin with a technical description of the recursive procedure and describe then the way methods to find homomorphism have to be implemented. After that we conclude this chapter with three sections on some generic conventions for the recognition of permutation groups, matrix groups, and black box groups respectively.</p>

<p><a id="s1ss0" name="s1ss0"></a></p>

<h4>4.1 The recursive procedure</h4>

<p>As explained at the beginning of this section, the heart of the recognition procedure is a function called <code class="func">RecogniseGeneric</code> (<a href="chap4.html#s1ss1"><b>4.1-1</b></a>) which gets a <strong class="pkg">GAP</strong> group object and returns a so-called "recognition info record" (see Subsection <a href="chap4.html#s2ss0"><b>4.2</b></a> for details). Success or failure will be indicated by this record being in the filter <code class="func">IsReady</code> (<a href="chap4.html#s2ss5"><b>4.2-5</b></a>) or not.</p>

<p>To know how to find homomorphisms the function gets as another argument a database of methods (see Section <a href="chap4.html#s3ss0"><b>4.3</b></a> for a description of the setup for methods for finding homomorphisms and Section <a href="chap3.html#s1ss0"><b>3.1</b></a> in Chapter <a href="chap3.html#s0ss0"><b>3.</b></a> for details about method databases). This database will be different according to the type of group in question.</p>

<p>To describe the algorithm executed by <code class="func">RecogniseGeneric</code> (<a href="chap4.html#s1ss1"><b>4.1-1</b></a>) we first summarize it in steps:</p>

<ol>
<li><p>Create a new, empty recognition info record.</p>

</li>
<li><p>Use the database of <code class="code">FindHomomorphism</code> methods and the method selection procedure described in Chapter <a href="chap3.html#s0ss0"><b>3.</b></a> to try to find a homomorphism onto a smaller group or an isomorphism onto another known group. Terminate with failure if this does not work.</p>

</li>
<li><p>If an isomorphism is found or a method somehow else recognises the group in question, such that we can write elements as straight line programs in the generators from now on, then make the recognition info record a leaf of the recognition tree and return success.</p>

</li>
<li><p>Otherwise the function sets up all the data for the homomorphism and calls itself with the image of the homomorphism. Note that this might use another database of recognition methods because the homomorphism might change the representation of the group.</p>

</li>
<li><p>After successful recognition of the factor group the procedure has to recognise the kernel of the homomorphism. The first step for this is to find generators. If they are not already known from the <code class="code">FindHomomorphism</code> method, they are created by producing random elements in the group, mapping them through the homomorphism, writing them as a straight line program in the images of the generators and applying this straight line program to the original generators. The quotient of the random element and the result of the straight line program lies in the kernel of the homomorphism. After creating 20 random generators of the kernel we assume for the moment that they generate the kernel.</p>

</li>
<li><p>The function <code class="func">RecogniseGeneric</code> (<a href="chap4.html#s1ss1"><b>4.1-1</b></a>) can now call itself for the kernel. After successful recognition of the kernel all the data for the node is completed and success is returned.</p>

</li>
<li><p>The function <code class="func">RecogniseGeneric</code> (<a href="chap4.html#s1ss1"><b>4.1-1</b></a>) now acquires preimages of the nice generators behind the homomorphism and appends the nice generators of the kernel. This list of generators is now the list of nice generators for the current node.</p>

</li>
</ol>
<p>Note that with the collected data one can write arbitrary elements of the group as a straight line program in the generators as follows:</p>

<ol>
<li><p>Map the element through the homomorphism.</p>

</li>
<li><p>Write the element in the factor group as a product of the nice generators in the factor group.</p>

</li>
<li><p>Apply the resulting straight line program to the preimages of those nice generators and calculate the quotient, which will now lie in the kernel.</p>

</li>
<li><p>Write the kernel element as a straight line program in the kernel generators.</p>

</li>
<li><p>Assemble both straight line programs to one bigger straight line program (which is now in terms of our own nice generators) and return it.</p>

</li>
</ol>
<p>If this procedure fails in the fourth step, this indicates that our random generators for the kernel did not yet generate the full kernel and makes further recognition steps necessary. This will not happen after a successful verification phase.</p>

<p>The latter procedure to write elements as straight line programs in the generators is implemented in the function <code class="func">SLPforElementGeneric</code> (<a href="chap4.html#s3ss2"><b>4.3-2</b></a>) which will be called automatically if one calls the <code class="func">SLPforElement</code> (<a href="chap4.html#s2ss15"><b>4.2-15</b></a>) function of the resulting recognition info record (see <code class="func">slpforelement</code> (<a href="chap4.html#s2ss14"><b>4.2-14</b></a>)).</p>

<p>It is now high time to give you the calling details of the main recursive recognition function:</p>

<p><a id="s1ss1" name="s1ss1"></a></p>

<h5>4.1-1 RecogniseGeneric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecogniseGeneric</code>( <var>H, methoddb, depth[, knowledge]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecognizeGeneric</code>( <var>H, methoddb, depth[, knowledge]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b><code class="code">fail</code> for failure or a recognition info record.</p>

<p><var>H</var> must be a <strong class="pkg">GAP</strong> group object, <var>methoddb</var> must be a method database in the sense of Section <a href="chap3.html#s1ss0"><b>3.1</b></a> containing <code class="code">FindHomomorphism</code> methods in the sense of Section <a href="chap4.html#s3ss0"><b>4.3</b></a>. <var>depth</var> is an integer which measures the depth in the recognition tree. It will be increased by one for each step we go into the tree. The top level has depth 0. <var>knowledge</var> is an optional record the components of which are copied into the new recognition info record which is created for the group <var>H</var>. Especially the component <code class="code">hints</code> can contain a list of additional find homomorphism methods (described by records as in Section <a href="chap3.html#s1ss0"><b>3.1</b></a>) which is prepended to the method database in <var>methoddb</var> before the recognition starts. This feature is intended to give hints about prior knowledge about which find homomorphism method might succeed.</p>

<p>The function performs the algorithm described above and returns either <code class="code">fail</code> in case of failure or a recognition info record in case of success. For the content and definition of recognition info records see Section <a href="chap4.html#s2ss0"><b>4.2</b></a>.</p>

<p>The user will usually not call this function directly, but will use the following convenience functions:</p>

<p><a id="s1ss2" name="s1ss2"></a></p>

<h5>4.1-2 RecognisePermGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecognisePermGroup</code>( <var>H</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecognizePermGroup</code>( <var>H</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b><code class="code">fail</code> for failure or a recognition info record.</p>

<p><var>H</var> must be a <strong class="pkg">GAP</strong> permutation group object. This function calls <code class="func">RecogniseGeneric</code> (<a href="chap4.html#s1ss1"><b>4.1-1</b></a>) with the method database used for permutation groups, which is stored in the global variable <code class="func">FindHomDbPerm</code> (<a href="chap4.html#s1ss6"><b>4.1-6</b></a>), and no prior knowledge.</p>

<p><a id="s1ss3" name="s1ss3"></a></p>

<h5>4.1-3 RecogniseMatrixGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecogniseMatrixGroup</code>( <var>H</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecognizeMatrixGroup</code>( <var>H</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b><code class="code">fail</code> for failure or a recognition info record.</p>

<p><var>H</var> must be a <strong class="pkg">GAP</strong> matrix group object. This function calls <code class="func">RecogniseGeneric</code> (<a href="chap4.html#s1ss1"><b>4.1-1</b></a>) with the method database used for matrix groups, which is stored in the global variable <code class="func">FindHomDbMatrix</code> (<a href="chap4.html#s1ss9"><b>4.1-9</b></a>), and no prior knowledge.</p>

<p><a id="s1ss4" name="s1ss4"></a></p>

<h5>4.1-4 RecogniseBBGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecogniseBBGroup</code>( <var>H</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecognizeBBGroup</code>( <var>H</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b><code class="code">fail</code> for failure or a recognition info record.</p>

<p><var>H</var> must be a <strong class="pkg">GAP</strong> black box group object. This function calls <code class="func">RecogniseGeneric</code> (<a href="chap4.html#s1ss1"><b>4.1-1</b></a>) with the method database used for black box groups, which is stored in the global variable <code class="func">FindHomDbBB</code> (<a href="chap4.html#s1ss12"><b>4.1-12</b></a>), and no prior knowledge.</p>

<p><a id="s1ss5" name="s1ss5"></a></p>

<h5>4.1-5 RecogniseGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecogniseGroup</code>( <var>H</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecognizeGroup</code>( <var>H</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b><code class="code">fail</code> for failure or a recognition info record.</p>

<p><var>H</var> must be a <strong class="pkg">GAP</strong> group object. This function automatically dispatches to one of the three previous functions <code class="func">RecognisePermGroup</code> (<a href="chap4.html#s1ss2"><b>4.1-2</b></a>), <code class="func">RecogniseMatrixGroup</code> (<a href="chap4.html#s1ss3"><b>4.1-3</b></a>), or <code class="func">RecogniseBBGroup</code> (<a href="chap4.html#s1ss4"><b>4.1-4</b></a>), according to the type of the group <var>H</var>.</p>

<p><a id="s1ss6" name="s1ss6"></a></p>

<h5>4.1-6 FindHomDbPerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FindHomDbPerm</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>This list contains the methods for finding homomorphisms for permutation group recognition that are stored in the record <code class="func">FindHomMethodsPerm</code> (<a href="chap4.html#s1ss7"><b>4.1-7</b></a>). As described in Section <a href="chap3.html#s1ss0"><b>3.1</b></a> each method is described by a record. The list is always sorted with respect to decreasing ranks. The order in this list tells in which order the methods should be applied. Use <code class="func">AddMethod</code> (<a href="chap3.html#s1ss1"><b>3.1-1</b></a>) to add methods to this database.</p>

<p><a id="s1ss7" name="s1ss7"></a></p>

<h5>4.1-7 FindHomMethodsPerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FindHomMethodsPerm</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>In this global record the functions that are methods for finding homomorphisms for permutation group recognition are stored. We collect them all in this record such that we do not use up too many global variable names.</p>

<p><a id="s1ss8" name="s1ss8"></a></p>

<h5>4.1-8 SLPforElementFuncsPerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SLPforElementFuncsPerm</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>This global record holds the functions that are methods for writing group elements as straight line programs (SLPs) in terms of the generators after successful permutation group recognition. We collect them all in this record such that we do not use up too many global variable names.</p>

<p><a id="s1ss9" name="s1ss9"></a></p>

<h5>4.1-9 FindHomDbMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FindHomDbMatrix</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>This list contains the methods for finding homomorphisms for matrix group recognition that are stored in the record <code class="func">FindHomMethodsMatrix</code> (<a href="chap4.html#s1ss10"><b>4.1-10</b></a>). As described in Section <a href="chap3.html#s1ss0"><b>3.1</b></a> each method is described by a record. The list is always sorted with respect to decreasing ranks. The order in this list tells in which order the methods should be applied. Use <code class="func">AddMethod</code> (<a href="chap3.html#s1ss1"><b>3.1-1</b></a>) to add methods to this database.</p>

<p><a id="s1ss10" name="s1ss10"></a></p>

<h5>4.1-10 FindHomMethodsMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FindHomMethodsMatrix</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>In this global record the functions that are methods for finding homomorphisms for matrix group recognition are stored. We collect them all in this record such that we do not use up too many global variable names.</p>

<p><a id="s1ss11" name="s1ss11"></a></p>

<h5>4.1-11 SLPforElementFuncsMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SLPforElementFuncsMatrix</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>This global record holds the functions that are methods for writing group elements as straight line programs (SLPs) in terms of the generators after successful matrix group recognition. We collect them all in this record such that we do not use up too many global variable names.</p>

<p><a id="s1ss12" name="s1ss12"></a></p>

<h5>4.1-12 FindHomDbBB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FindHomDbBB</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>This list contains the methods for finding homomorphisms for black box group recognition that are stored in the record <code class="func">FindHomMethodsBB</code> (<a href="chap4.html#s1ss13"><b>4.1-13</b></a>). As described in Section <a href="chap3.html#s1ss0"><b>3.1</b></a> each method is described by a record. The list is always sorted with respect to decreasing ranks. The order in this list tells in which order the methods should be applied. Use <code class="func">AddMethod</code> (<a href="chap3.html#s1ss1"><b>3.1-1</b></a>) to add methods to this database.</p>

<p><a id="s1ss13" name="s1ss13"></a></p>

<h5>4.1-13 FindHomMethodsBB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FindHomMethodsBB</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>In this global record the functions that are methods for finding homomorphisms for black box group recognition are stored. We collect them all in this record such that we do not use up too many global variable names.</p>

<p><a id="s1ss14" name="s1ss14"></a></p>

<h5>4.1-14 SLPforElementFuncsBB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SLPforElementFuncsBB</code></td><td class="tdright">( global variable )</td></tr></table></div>
<p>This global record holds the functions that are methods for writing group elements as straight line programs (SLPs) in terms of the generators after successful black box group recognition. We collect them all in this record such that we do not use up too many global variable names.</p>

<p><a id="s2ss0" name="s2ss0"></a></p>

<h4>4.2 Recognition info records</h4>

<p>A recognition info record is a <strong class="pkg">GAP</strong> positional object. It is a member of the family</p>

<p><a id="s2ss1" name="s2ss1"></a></p>

<h5>4.2-1 RecognitionInfoFamily</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RecognitionInfoFamily</code></td><td class="tdright">( family )</td></tr></table></div>
<p>and is in the category</p>

<p><a id="s2ss2" name="s2ss2"></a></p>

<h5>4.2-2 IsRecognitionInfo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsRecognitionInfo</code></td><td class="tdright">( Category )</td></tr></table></div>
<p>and is <code class="func">IsAttributeStoringRep</code> (<a href="/users/neunhoef/4.0/doc/htm/prg/CHAP004.htm#SECT005"><b>Prg Tutorial: IsAttributeStoringRep</b></a>), such that we can define attributes for it, the values of which are stored once they are known. A recognition info record always represents a whole binary tree of such records, see the attributes <code class="func">factor</code> (<a href="chap4.html#s2ss10"><b>4.2-10</b></a>) and <code class="func">kernel</code> (<a href="chap4.html#s2ss11"><b>4.2-11</b></a>) below.</p>

<p>The following filters are defined for recognition info records:</p>

<p><a id="s2ss3" name="s2ss3"></a></p>

<h5>4.2-3 IsLeaf</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsLeaf</code></td><td class="tdright">( Flag )</td></tr></table></div>
<p>This flag indicates, whether or not a recognition info record represents a leaf in the recognition tree. If it is not set, one finds at least one of the attributes <code class="func">factor</code> (<a href="chap4.html#s2ss10"><b>4.2-10</b></a>) and <code class="func">kernel</code> (<a href="chap4.html#s2ss11"><b>4.2-11</b></a>) set for the corresponding node. This flag is normally reset and has to be set by a find homomorphism method to indicate a leaf.</p>

<p><a id="s2ss4" name="s2ss4"></a></p>

<h5>4.2-4 DoNotRecurse</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DoNotRecurse</code></td><td class="tdright">( Flag )</td></tr></table></div>
<p>This flag can be set by a find homomorphism method to indicate that the generic recursive procedure should not recurse further down, even if the corresponding node is not a leaf. It is then the responsibility of the find homomorphism method to complete the tree below.</p>

<p><a id="s2ss5" name="s2ss5"></a></p>

<h5>4.2-5 IsReady</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsReady</code></td><td class="tdright">( Flag )</td></tr></table></div>
<p>This flag indicates during the recognition procedure, whether a node in the recognition tree is already completed or not. It is mainly set for debugging purposes during the recognition. However, if the recognition fails somewhere in a leaf, this flag is not set and all nodes above will also not have this flag set. In this way one can see whether the recognition failed and where the problem was. If a find homomorphism method uses <code class="func">DoNotRecurse</code> (<a href="chap4.html#s2ss4"><b>4.2-4</b></a>) to avoid further recursion it acquires thereby responsibility to set the <code class="func">IsReady</code> flag in the corresponding subtree upon completion.</p>

<p>The following attributes are defined for recognition info records:</p>

<p><a id="s2ss6" name="s2ss6"></a></p>

<h5>4.2-6 group</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; group</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The value of this attribute is the group that is to be recognised by this recognition info record <var>ri</var>. This attribute is always present during recognition and after completion. Note that the generators of the group object stored here always have a memory attached to them, such that elements that are generated from them remember, how they were acquired.</p>

<p><a id="s2ss7" name="s2ss7"></a></p>

<h5>4.2-7 homom</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; homom</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The value of this attribute is the homomorphism that was found from the group described by the recognition info record <var>ri</var> as a <strong class="pkg">GAP</strong> object. It is set by a find homomorphism method that succeeded to find a homomorphism (or isomorphism). It does not have to be set in leaf nodes of the recognition tree.</p>

<p><a id="s2ss8" name="s2ss8"></a></p>

<h5>4.2-8 nicegens</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; nicegens</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The value of this attribute must be set for all nodes and contains the nice generators. The <code class="func">SLPforElement</code> (<a href="chap4.html#s2ss15"><b>4.2-15</b></a>) function of the node will write its straight line program in terms of these nice generators. For leaf nodes, the find homomorphism method is responsible to set the value of <code class="func">nicegens</code>. By default, the original generators of the group at this node are taken. For a homomorphism (or isomorphism), the <code class="func">nicegens</code> will be the concatenation of preimages of the <code class="func">nicegens</code> of the factor group (see <code class="func">pregensfac</code> (<a href="chap4.html#s2ss9"><b>4.2-9</b></a>)) and the <code class="func">nicegens</code> of the kernel. A find homomorphism method does not have to set <code class="func">nicegens</code> if it finds a homomorphism. Note however, that such a find homomorphism method has to ensure somehow, that preimages of the <code class="func">nicegens</code> of the factor group can be acquired. See <code class="func">calcnicegens</code> (<a href="chap4.html#s2ss18"><b>4.2-18</b></a>), <code class="func">CalcNiceGens</code> (<a href="chap4.html#s2ss21"><b>4.2-21</b></a>) and <code class="func">slptonice</code> (<a href="chap4.html#s2ss22"><b>4.2-22</b></a>) for instructions.</p>

<p><a id="s2ss9" name="s2ss9"></a></p>

<h5>4.2-9 pregensfac</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; pregensfac</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The value of this attribute is only set for homomorphism nodes. In that case it contains preimages of the nice generators in the factor group. This attribute is set automatically by the generic recursive recognition function using the mechanism described with the attribute <code class="func">calcnicegens</code> (<a href="chap4.html#s2ss18"><b>4.2-18</b></a>) below. A find homomorphism does not have to touch this attribute.</p>

<p><a id="s2ss10" name="s2ss10"></a></p>

<h5>4.2-10 factor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; factor</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The value of this attribute is the recognition info record of the image of the homomorphism that was found from the group described by the recognition info record <var>ri</var>. It is set by the generic recursive procedure after a find homomorphism method has succeeded to find a homomorphism (or isomorphism). It does not have to be set in leaf nodes of the recognition tree. This attribute value provides the link to the "factor" subtree of the recognition tree.</p>

<p><a id="s2ss11" name="s2ss11"></a></p>

<h5>4.2-11 kernel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; kernel</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The value of this attribute is the recognition info record of the kernel of the homomorphism that was found from the group described by the recognition info record <var>ri</var>. It is set by the generic recursive procedure after a find homomorphism method has succeeded to find a homomorphism (or isomorphism). It does not have to be set in leaf nodes of the recognition tree or if the homomorphism is known to be an isomorphism. In the latter case the value of the attribute is set to <code class="code">fail</code>. This attribute value provides the link to the "kernel" subtree of the recognition tree.</p>

<p><a id="s2ss12" name="s2ss12"></a></p>

<h5>4.2-12 parent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; parent</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The value of this attribute is the recognition info record of the parent of this node in the recognition tree. The top node does not have this attribute set.</p>

<p><a id="s2ss13" name="s2ss13"></a></p>

<h5>4.2-13 fhmethsel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; fhmethsel</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The value of this attribute is the record returned by the method selection (see Section <a href="chap3.html#s2ss0"><b>3.2</b></a>) after it ran to find a homomorphism (or isomorphism). It is there to be able to see which methods were tried until the recognition of the node was completed.</p>

<p><a id="s2ss14" name="s2ss14"></a></p>

<h5>4.2-14 slpforelement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; slpforelement</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>After the recognition phase is completed for the node <var>ri</var>, we are by definition able to write arbitrary elements in the group described by this node as a straight line program (SLP) in terms of the nice generators stored in <code class="func">nicegens</code> (<a href="chap4.html#s2ss8"><b>4.2-8</b></a>). This attribute value is a function taking the node <var>ri</var> and a group element as its arguments and returning the above mentioned straight line program. For the case that a find homomorphism method succeeds in finding a homomorphism, the generic recursive function sets this attribute to the function <code class="func">SLPforElementGeneric</code> (<a href="chap4.html#s3ss2"><b>4.3-2</b></a>) which does the job for the generic homomorphism situation. In all other cases the successful find homomorphism method has to set this attribute to a function doing the job. The find homomorphism method is free to store additional data in the recognition info record or the group object such that the <code class="func">SLPforElement</code> (<a href="chap4.html#s2ss15"><b>4.2-15</b></a>) function can work.</p>

<p><a id="s2ss15" name="s2ss15"></a></p>

<h5>4.2-15 SLPforElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SLPforElement</code>( <var>ri, x</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>a straight line program expressing <var>x</var> in the nice generators.</p>

<p>This is a wrapper function which extracts the value of the attribute <code class="func">slpforelement</code> (<a href="chap4.html#s2ss14"><b>4.2-14</b></a>) and calls that function with the arguments <var>ri</var> and <var>x</var>.</p>

<p><a id="s2ss16" name="s2ss16"></a></p>

<h5>4.2-16 presentation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; presentation</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>After the verification phase, the presentation is stored here. Details have still to be decided upon.</p>

<p><a id="s2ss17" name="s2ss17"></a></p>

<h5>4.2-17 methodsforfactor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; methodsforfactor</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This attribute is initialized at the beginning of the recursive recognition function with the database of find homomorphism methods that was used to recognise the group corresponding to the recognition info record <var>ri</var>. If the found homomorphism changes the representation of the group (going for example from a matrix group to a permutation group), the find homomorphism method can report this by exchanging the database of find homomorphism methods to be used in the recognition of the image of the homomorphism by setting the value of this attribute to something different. It lies in the responsibility of the find homomorphism method to do so, if the representation changes through the homomorphism.</p>

<p>The following two attributes are concerned with the relation between the original generators and the nice generators for a node. They are used to transport this information from a successful find homomorphism method up to the recursive recognition function:</p>

<p><a id="s2ss18" name="s2ss18"></a></p>

<h5>4.2-18 calcnicegens</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; calcnicegens</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>To make the recursion work, we have to acquire preimages of the nice generators in factor groups under the homomorphism found. But we want to keep the information, how the nice generators were found, locally at the node where they were found. This attribute solves this problem of acquiring preimages in the following way: Its value must be a function, taking the recognition info record <var>ri</var> as first argument, and a list <var>origgens</var> of preimages of the original generators of the current node, and has to return corresponding preimages of the nice generators. Usually this task can be done by storing a straight line program writing the nice generators in terms of the original generators and executing this with inputs <var>origgens</var>. Therefore the default value of this attribute is the function <code class="func">CalcNiceGensGeneric</code> (<a href="chap4.html#s2ss19"><b>4.2-19</b></a>) described below.</p>

<p><a id="s2ss19" name="s2ss19"></a></p>

<h5>4.2-19 CalcNiceGensGeneric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CalcNiceGensGeneric</code>( <var>ri, origgens</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>a list of preimages of the nice generators</p>

<p>This is the default function for leaf nodes for the attribute <code class="func">calcnicegens</code> (<a href="chap4.html#s2ss18"><b>4.2-18</b></a>) described above. It does the following: If the value of the attribute <code class="func">slptonice</code> (<a href="chap4.html#s2ss22"><b>4.2-22</b></a>) is set, then it must be a straight line program expressing the nice generators in terms of the original generators of this node. In that case, this straight line program is executed with <var>origgens</var> as inputs and the result is returned. Otherwise, <var>origgens</var> is returned as is. Therefore a leaf node just has to to nothing if the nice generators are equal to the original generators and just can store the right straight line program into the attribute <code class="func">slptonice</code> (<a href="chap4.html#s2ss22"><b>4.2-22</b></a>) to fulfill its duties.</p>

<p><a id="s2ss20" name="s2ss20"></a></p>

<h5>4.2-20 CalcNiceGensHomNode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CalcNiceGensHomNode</code>( <var>ri, origgens</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>a list of preimages of the nice generators</p>

<p>This is the default function for homomorphism node for the attribute <code class="func">calcnicegens</code> (<a href="chap4.html#s2ss18"><b>4.2-18</b></a>). It just delegates to factor and kernel of the homomorphism, as the nice generators of a homomorphism (or isomorphism) node are just the concatenation of the nice generators of the factor and the kernel. A find homomorphism method finding a homomorphism or isomorphism does not have to do anything with respect to nice generators.</p>

<p><a id="s2ss21" name="s2ss21"></a></p>

<h5>4.2-21 CalcNiceGens</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CalcNiceGens</code>( <var>ri, origgens</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>a list of preimages of the nice generators</p>

<p>This is a wrapper function which extracts the value of the attribute <code class="func">calcnicegens</code> (<a href="chap4.html#s2ss18"><b>4.2-18</b></a>) and calls that function with the arguments <var>ri</var> and <var>origgens</var>.</p>

<p><a id="s2ss22" name="s2ss22"></a></p>

<h5>4.2-22 slptonice</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; slptonice</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>As described above, the value, if set, must be a straight line program expressing the nice generators at this node in terms of the original generators. This is for leaf nodes, that choose to use the default function <code class="func">CalcNiceGensGeneric</code> (<a href="chap4.html#s2ss19"><b>4.2-19</b></a>) installed in the <code class="func">calcnicegens</code> (<a href="chap4.html#s2ss18"><b>4.2-18</b></a>) attribute.</p>

<p>The following three attributes are concerned with the administration of the kernel of a found homomorphism. Find homomorphism methods use them to report to the main recursive recognition function their knowledge about the kernel:</p>

<p><a id="s2ss23" name="s2ss23"></a></p>

<h5>4.2-23 gensN</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; gensN</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The value of this mutable attribute is a list of generators of the kernel of the homomorphism found at the node <var>ri</var>. It is initialized as an empty list when the recursive recognition function starts. Successful find homomorphism methods may append generators of the kernel to this list if they happen to stumble on them. After successful recognition of the image of the homomorphism the main recursive recognition function will try to create a few more generators of the kernel and append them to the list which is the value of the attribute <code class="func">gensN</code>. The exact behaviour depends on the value of the attribute <code class="func">findgensNmeth</code> (<a href="chap4.html#s2ss24"><b>4.2-24</b></a>) below. The list of generators after that step is used to recognise the kernel. Note that the generators in <code class="func">gensN</code> have a memory attached to them, how they were obtained in terms of the original generators of the current node.</p>

<p><a id="s2ss24" name="s2ss24"></a></p>

<h5>4.2-24 findgensNmeth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; findgensNmeth</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This attribute decides about how generators of the kernel of a found homomorphism are produced. Its value has to be a record with at least two components bound. The first is <code class="code">method</code> which holds a function taking at least one argument <var>ri</var> and possibly more, and does not return anything. The second is <code class="code">args</code> which holds a list of arguments for the above mentioned function. The real list of arguments is derived by prepending the recognition info record to the list of arguments in <code class="code">args</code>. That is, the following code is used to call the method:</p>


<table class="example">
<tr><td><pre>

    methgensN := findmethgensN(ri);
    CallFuncList(methgensN(ri).method,Concatenation([ri],methgensN.args));

</pre></td></tr></table>

<p>The record is initialised upon creation of the recognition info record to calling <code class="func">FindKernelRandom</code> (<a href="chap4.html#s2ss25"><b>4.2-25</b></a>) with one argument of 20 (in addition to the first argument <var>ri</var>). See below for a choice of possible find kernel methods.</p>

<p><a id="s2ss25" name="s2ss25"></a></p>

<h5>4.2-25 FindKernelRandom</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FindKernelRandom</code>( <var>ri, n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>nothing</p>

<p><var>n</var> random elements are generated, mapped through the homomorphism, written as a straight line program in the generators. Then the straight line program is executed with the original generators thereby producing elements in the same coset. The quotients are then elements of the kernel.</p>

<p><a id="s2ss26" name="s2ss26"></a></p>

<h5>4.2-26 FindKernelDoNothing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FindKernelDoNothing</code>( <var>ri, n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>nothing</p>

<p>Does nothing. This function is intended to be set as method for producing kernel elements if the kernel is known to be trivial or if one knows, that the attribute <code class="func">gensN</code> (<a href="chap4.html#s2ss23"><b>4.2-23</b></a>) already contains a complete set of generators for the kernel.</p>

<p><a id="s2ss27" name="s2ss27"></a></p>

<h5>4.2-27 FindKernelFastNormalClosure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FindKernelFastNormalClosure</code>( <var>ri, nr</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>a probable generating set for the normal closure</p>

<p>This function takes the group G in the <code class="func">group</code> (<a href="chap4.html#s2ss6"><b>4.2-6</b></a>) attribute in <var>ri</var> and the list of generators gens of the kernel in <code class="func">gensN</code> (<a href="chap4.html#s2ss23"><b>4.2-23</b></a>) and the positive integer <var>nr</var>. This function computes a probable generating set of the normal closure in <var>G</var> of the group generated by the generators in <var>gens</var>. The integer <var>nr</var> indicates how hard it should try.</p>

<p><a id="s2ss28" name="s2ss28"></a></p>

<h5>4.2-28 gensNslp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; gensNslp</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The recursive recognition function calculates a straight line program that computes the generators of the kernel stored in <code class="func">gensN</code> (<a href="chap4.html#s2ss23"><b>4.2-23</b></a>) in terms of the generators of the group recognised by <var>ri</var>. This straight line program is stored in the value of this mutable attribute. It is used by the generic function <code class="func">SLPforElementGeneric</code> (<a href="chap4.html#s3ss2"><b>4.3-2</b></a>).</p>

<p><a id="s2ss29" name="s2ss29"></a></p>

<h5>4.2-29 immediateverification</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; immediateverification</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Sometimes a find homomorphism has information that it will be difficult to create generators for the kernel, for example if it is known that the kernel will need lots of generators. In that case this attribute with the default boolean value <code class="code">false</code> can be set to <code class="code">true</code>. In that case, the generic recursive recognition function will perform an immediate verification phase after the kernel has been recognised. This is done as follows: A few random elements are created, mapped through the homomorphism and written as an SLP in the nice generators there. Then this SLP is executed with preimages of those nice generators. The quotient lies then in the kernel and is written as an SLP in terms of the nice generators of the would be kernel. If this is not possible, then probably the creation of kernel generators was not complete and a few more kernel elements are produced and recognition in the kernel starts all over again. This is for example done in case of the "Imprimitive" method which maps onto the action on a block system. In that case, the kernel often needs lots of generators.</p>

<p>The following attributes are used to give a successful find homomorphism method further possibilities to transport knowledge about the group recognised by the current recognition info record to the factor or kernel of the found homomorphism:</p>

<p><a id="s2ss30" name="s2ss30"></a></p>

<h5>4.2-30 forkernel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; forkernel</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This attribute is initialised to a record with only the component <code class="code">hints</code> bound to an empty list at the beginning of the recursive recognition function. Find homomorphism methods can put acquired knowledge about the group to be recognised (like for example an invariant subspace of a matrix group) into this record. When a homomorphism is found and recognition goes on in its kernel, the value of this attribute is taken as initialisation data for the newly created recognition info record for the kernel. Thus, information is transported down to the recognition process for the kernel. The component <code class="code">hints</code> is special insofar as it has to contain records describing find homomorphism methods which might be particularly successful. They are prepended to the find homomorphism method database such that they are called before any other methods. This is a means to give hints to the recognition procedure in the kernel, because often during the finding of a homomorphism knowledge is acquired which might help the recognition of the kernel.</p>

<p><a id="s2ss31" name="s2ss31"></a></p>

<h5>4.2-31 forfactor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; forfactor</code>( <var>ri</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This attribute is initialised to a record with only the component <code class="code">hints</code> bound to an empty list at the beginning of the recursive recognition function. Find homomorphism methods can put acquired knowledge about the group to be recognised (like for example an invariant subspace of a matrix group) into this record. When a homomorphism is found and recognition goes on in its image, the value of this attribute is taken as initialisation data for the newly created recognition info record for the factor. Thus, information is transported down to the recognition process for the factor. The component <code class="code">hints</code> is special insofar as it has to contain records describing find homomorphism methods which might be particularly successful. They are prepended to the find homomorphism method database such that they are called before any other methods. This is a means to give hints to the recognition procedure in the factor, because often during the finding of a homomorphism knowledge is acquired which might help the recognition of the factor.</p>

<p><a id="s3ss0" name="s3ss0"></a></p>

<h4>4.3 Methods to find homomorphisms</h4>

<p>A "find homomorphism method" has the objective to find, given a group G, either a homomorphism from G onto a group, or an isomorphism, or to fail.</p>

<p>In case a homomorphism is found, it has to report that homomorphism back to the calling recursive recognition function together with as much information about the kernel as possible.</p>

<p>If a find homomorphism method determines that the node is a leaf in the recognition tree, then it has to ensure, that arbitrary elements can be written in terms of the nice generators of G (solving the word problem). It does so by returning a function together with possible extra data, that can perform this job.</p>

<p>Of course, the find homomorphism method also has to report, how the nice generators were acquired in terms of the original generators.</p>

<p>If the find homomorphism method fails, it has to report, whether it has failed forever or if it possibly makes sense to try to call this method again later.</p>

<p>Find homomorphism methods have to fit into the framework for method selection described in Chapter <a href="chap3.html#s0ss0"><b>3.</b></a>. We now begin to describe the technical details of how a find homomorphism method has to look like and what it has to do and what it is not allowed to do. We first explain the calling convention by means of a hypothetical function:</p>

<p><a id="s3ss1" name="s3ss1"></a></p>

<h5>4.3-1 FindHomomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; FindHomomorphism</code>( <var>ri, G</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>One of the values <code class="code">true</code>, <code class="code">false</code>, <code class="code">fail</code>, or <code class="code">NotApplicable</code>.</p>

<p>Find homomorphism methods take two arguments <var>ri</var> and <var>G</var>, of which <var>ri</var> is a recognition info record and <var>G</var> is a <strong class="pkg">GAP</strong> group object. The return value is one of the four possible values in the framework for method selection described in Chapter <a href="chap3.html#s0ss0"><b>3.</b></a> indicating success, failure, or (temporary) non-applicability. The above mentioned additional information in case of success are all returned by changing the recognition info record <var>ri</var>. For the conventions about what a find homomorphism method has to do and return see below.</p>

<p>A failed or not applicable find homomorphism method does not have to report or do anything in the recognition info record <var>ri</var>. However, it can collect information and store it either in the group object or in the recognition info record. Note that for example it might be that a failed find homomorphism method acquires additional information that allows another find homomorphism method to become applicable.</p>

<p>A not applicable find homomorphism method should find out so relatively quickly, because otherwise the whole process might be slowed down, because a find homomorphism method repeatedly ponders about its applicability. Usually no big calculations should be triggered just to decide applicability.</p>

<p>A successful find homomorphism method has the following duties:</p>


<dl>
<dt><strong>for leaves:</strong></dt>
<dd><p>First it has to report whether the current node is a leaf or not in the recognition tree. That is, in case a leaf was found the method has to do <code class="code">SetFilterObj(ri,IsLeaf);</code> thereby setting the <code class="func">IsLeaf</code> (<a href="chap4.html#s2ss3"><b>4.2-3</b></a>) flag.</p>

<p>If the method for some reason chooses to finish the tree below the current node on its own, it can set the flag <code class="func">DoNotRecurse</code> (<a href="chap4.html#s2ss4"><b>4.2-4</b></a>) to indicate that no further action is required by the generic recognition function. The method is then responsible for correctly setting the <code class="func">IsLeaf</code> (<a href="chap4.html#s2ss3"><b>4.2-3</b></a>) and <code class="func">IsReady</code> (<a href="chap4.html#s2ss5"><b>4.2-5</b></a>) flags in the whole subtree.</p>

<p>A method finding a homomorphism which is not an isomorphism indicates so by not touching the flags.</p>

</dd>
<dt><strong>for leaves: <code class="func">SLPforElement</code> (<a href="chap4.html#s2ss15"><b>4.2-15</b></a>) function</strong></dt>
<dd><p>If a find homomorphism method has produced a leaf in the recognition tree or has set the <code class="func">DoNotRecurse</code> (<a href="chap4.html#s2ss4"><b>4.2-4</b></a>) flag, then it has to set the attribute <code class="func">slpforelement</code> (<a href="chap4.html#s2ss14"><b>4.2-14</b></a>) to a function like <code class="func">SLPforElementGeneric</code> (<a href="chap4.html#s3ss2"><b>4.3-2</b></a>) that can write an arbitrary element in <var>G</var> as a straight line program in the nice generators of <var>G</var>. The method may store additional data into the recognition info record for this to work. It does not have to set any other value in <var>ri</var>.</p>

</dd>
<dt><strong>for leaves: information about nice generators</strong></dt>
<dd><p>If a find homomorphism method has produced a leaf in the recognition tree, then it has to report what are the nice generators of the group described by the leaf. To this end, it has three possibilities: Firstly to do nothing, which means, that the original generators are the nice generators. Secondly to store a straight line program expressing the nice generators in terms of the original generators into the attribute <code class="func">slptonice</code> (<a href="chap4.html#s2ss22"><b>4.2-22</b></a>). In that case, the generic frame work takes care of the rest. The third possibility is to store a function into the value of the attribute <code class="func">calcnicegens</code> (<a href="chap4.html#s2ss18"><b>4.2-18</b></a>) which can calculate preimages of the nice generators in terms of preimages of the original generators. See the function <code class="func">CalcNiceGensGeneric</code> (<a href="chap4.html#s2ss19"><b>4.2-19</b></a>) for an example of such a function.</p>

</dd>
<dt><strong>for non-leaves: the homomorphism itself</strong></dt>
<dd><p>If a find homomorphism method has found a homomorphism, it has to store it as a <strong class="pkg">GAP</strong> homomorphism object from <var>G</var> to the image group in the attribute <code class="func">homom</code> (<a href="chap4.html#s2ss7"><b>4.2-7</b></a>). Note that if your homomorphism changes the representation (for example going from matrix groups to permutation groups), you will have to set the attribute <code class="func">methodsforfactor</code> (<a href="chap4.html#s2ss17"><b>4.2-17</b></a>) accordingly.</p>

</dd>
<dt><strong>for non-leaves: kernel generators</strong></dt>
<dd><p>If a find homomorphism method has found a homomorphism, it has to provide information about already known generators of the kernel. This is done firstly by appending known generators of the kernel to the attribute value of <code class="func">gensN</code> (<a href="chap4.html#s2ss23"><b>4.2-23</b></a>) and secondly by leaving or changing the attribute <code class="func">findgensNmeth</code> (<a href="chap4.html#s2ss24"><b>4.2-24</b></a>) to a record describing the method that should be used (for details see <code class="func">findgensNmeth</code> (<a href="chap4.html#s2ss24"><b>4.2-24</b></a>). If one does not change the default value, the recursive recognition function will generate 20 random elements in <var>G</var> and produce random generators of the kernel by dividing up a preimage of an image under the homomorphism. Note that generators in <code class="func">gensN</code> (<a href="chap4.html#s2ss23"><b>4.2-23</b></a>) have to have a memory attached to them that stores, how they were acquired from the generators of <var>G</var>.</p>

</dd>
<dt><strong>additional information</strong></dt>
<dd><p>A find homomorphism method may store any data into the attributes <code class="func">forkernel</code> (<a href="chap4.html#s2ss30"><b>4.2-30</b></a>) and <code class="func">forfactor</code> (<a href="chap4.html#s2ss31"><b>4.2-31</b></a>), which both are records. Components in these record that are bound during the recognition will be copied into the recognition info record of the kernel and factor respectively of a found homomorphism upon creation and thus are available to all find homomorphism methods called for the kernel and factor. This feature might be interesting to transport information that is relevant for the recognition of the kernel or factor and was acquired during the recognition of <var>G</var> itself.</p>

<p>A special role is played by the component <code class="code">hints</code>, which can hold a list of records describing find homomorphism methods that shall be tried first when recognising the kernel or factor.</p>

<p>In addition, a find homomorphism method might set the attribute <code class="func">immediateverification</code> (<a href="chap4.html#s2ss29"><b>4.2-29</b></a>) to true, if it considers the problem of finding kernel generators particularly difficult.</p>

</dd>
</dl>
<p>To explain the calling conventions for <code class="func">SLPforElement</code> (<a href="chap4.html#s2ss15"><b>4.2-15</b></a>) functions and for the sake of completeness we present now the function <code class="func">SLPforElementGeneric</code> (<a href="chap4.html#s3ss2"><b>4.3-2</b></a>) which is used for the case of a "homomorphism node":</p>

<p><a id="s3ss2" name="s3ss2"></a></p>

<h5>4.3-2 SLPforElementGeneric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SLPforElementGeneric</code>( <var>ri, x</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>a <strong class="pkg">GAP</strong> straight line program</p>

<p>This function takes as arguments a recognition info record <var>ri</var> and a group element <var>x</var>. It returns a <strong class="pkg">GAP</strong> straight line program that expresses the element <var>x</var> in terms of the nice generators of the group G recognised by <var>ri</var>.</p>

<p>This generic function here does exactly this job for the generic situation that we found a homomorphism from G to some other group say H with kernel N. It first maps <var>x</var> via the homomorphism to H and uses the recognition information there to write it as a straight line program in terms of the nice generators of H. Then it applies this straight line program to the preimages of those nice generators (see <code class="func">pregensfac</code> (<a href="chap4.html#s2ss9"><b>4.2-9</b></a>)) thereby finding an element y of G with x * y^-1 lying in the kernel N.</p>

<p>Then the function writes this element as a straight line program in the nice generators of N again using the recursively acquired recognition info about N. In the end a concatenated straight line program for x is built, which is in terms of the nice generators of the current node.</p>

<p><a id="s4ss0" name="s4ss0"></a></p>

<h4>4.4 Conventions for the recognition of permutation groups</h4>

<p>None so far.</p>

<p><a id="s5ss0" name="s5ss0"></a></p>

<h4>4.5 Conventions for the recognition of matrix groups</h4>

<p>First we want to remark that we are considering only the case of matrix groups over finite fields.</p>

<p>No conventions so far.</p>

<p><a id="s6ss0" name="s6ss0"></a></p>

<h4>4.6 Conventions for the recognition of black box groups</h4>

<p>No conventions so far.</p>


<div class="pcenter">
<table class="chlink"><tr><td><a href="chap0.html">Top of Book</a></td><td><a href="chap3.html">Previous Chapter</a></td><td><a href="chap5.html">Next Chapter</a></td></tr></table>
<br />


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chap4.html">4</a></td><td><a href="chap5.html">5</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>

</div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
