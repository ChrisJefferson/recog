  
  [1m[4m[31m3. Method Selection[0m
  
  The  setup  described  in  this chapter is intended for situations, in which
  lots  of  different  methods are available to fulfill a certain task, but in
  which  it  is  not  possible  in  the beginning to decide, which one to use.
  Therefore  this setup regulates, rather than just which method to choose, in
  which  order  the  various methods are tried. The methods themselves return,
  whether  they were successful and if not, whether it is sensible to try them
  again at a later stage.
  
  The  design is intentionally kept as simple as possible and at the same time
  as  versatile  as  possible,  thereby  providing a useful framework for many
  situations as described above.
  
  Note the differences to the [1mGAP[0m method selection, which is designed with the
  idea  in  mind  that it will be quite clear in most situations, which one is
  "the  best" method for a given set of input data, and that we do not want to
  try  different  things. On the other hand, the [1mGAP[0m method selection is quite
  complicated,  which  is  to some extend necessary to make sure, that lots of
  different  information  about  the objects in question can be used to really
  find the best method.
  
  Our  setup  here  in  particular has to fulfill the requirement, that in the
  end,  with  lots  of  methods installed, one still has to be able to have an
  overview and to "prove", that the whole system always does the right thing.
  
  
  [1m[4m[31m3.1 What are methods?[0m
  
  A  method  is  just  a  [1mGAP[0m  function  together with an agreement about what
  arguments  it  takes  and  what  result  it returns. The agreement about the
  arguments of course has to be made for every situation in which this generic
  method  selection  code  is  used,  and the user is completely free there. A
  method can (and has to) return one of the following four values:
  
  [1m[33m[22m[32mtrue[0m[0m
        means  that  the  method was successful and no more methods have to be
        tried.
  
  [1m[33m[22m[32mfalse[0m[0m
        means that the method was not successful and that there is no point to
        call the method again in this situation whatsoever.
  
  [1m[33m[22m[32mfail[0m[0m
        means  that  the  method  temporarily failed, that it however could be
        sensible  to  call  it  again in this situation at a later stage. This
        value  is  typical for a Las Vegas algorithm using randomised methods,
        which has failed, but which may succeed when called again.
  
  [1m[33m[22m[32mNotApplicable[0m[0m
        means that the method for some reason refused to do its work. However,
        it is possible that it will become applicable later such that it makes
        sense to call it again, may when more information is available.
  
  For  administration  in  the  method  selection,  a method is described by a
  record with the following components bound:
  
  [1m[33m[22m[32mmethod[0m[0m
        holds the function itself.
  
  [1m[33m[22m[32mrank[0m[0m
        holds an integer used to sort the various methods. Higher numbers mean
        that  the method is tried earlier. The numbering scheme is left to the
        user.
  
  [1m[33m[22m[32mstamp[0m[0m
        holds  a string value that uniquely describes the method. This is used
        for bookkeeping and to keep track of what has to be tried how often.
  
  [1m[33m[22m[32mcomment[0m[0m
        a string valued comment. This field is optional and can be left out.
  
  The  different methods for a certain task are collected in so-called "method
  databases".  A  [22m[36mmethod database[0m is just a list of records, each describing a
  method in the format described above. Usually, the ranks will be descending,
  but that is not necessary.
  
  There  is  one  convenience  function  to  put  a  new  method into a method
  database:
  
  [1m[4m[31m3.1-1 AddMethod[0m
  
  [1m[34m> AddMethod( [0m[22m[34mdb, meth, rank, stamp[, comment][0m[1m[34m ) ____________________[0mfunction
  [1mReturns:[0m  nothing
  
  [22m[34mdb[0m must be a method database (list of records, see above) with non-ascending
  rank  values.  [22m[34mmeth[0m is the method function, [22m[34mrank[0m the rank and [22m[34mstamp[0m a string
  valued  stamp.  The  optional  argument [22m[34mcomment[0m can be a string comment. The
  record describing the method is created and inserted at the correct position
  in the method database. Nothing is returned.
  
  
  [1m[4m[31m3.2 How methods are called[0m
  
  Whenever  the  method  selection  shall  be  used,  one  calls the following
  function:
  
  [1m[4m[31m3.2-1 CallMethods[0m
  
  [1m[34m> CallMethods( [0m[22m[34mdb, limit[, furtherargs][0m[1m[34m ) __________________________[0mfunction
  [1mReturns:[0m  a record [22m[32mms[0m describing this method selection procedure.
  
  The argument [22m[34mdb[0m must be a method database in the sense of Section [1m3.1[0m. [22m[34mlimit[0m
  must  be  a non-negative integer. [22m[34mfurtherargs[0m stands for an arbitrary number
  of  additional  arguments,  which  are handed down to the called methods. Of
  course  they  must  fulfill  the  conventions defined for the methods in the
  database [22m[34mdb[0m.
  
  The  function first creates a "method selection" record keeping track of the
  things  that happened during the method trying procedure, which is also used
  during  this  procedure.  Then it calls methods with the algorithm described
  below and in the end returns the method selection record in its final state.
  
  The method selection record has the following components:
  
  [1m[33m[22m[32mfalsemethods[0m[0m
        a record, in which for every method that returned [22m[32mfalse[0m the value 1 is
        bound to the component with name the stamp of the method.
  
  [1m[33m[22m[32mfailedmethods[0m[0m
        a  record,  in  which  for every time a method returned [22m[32mfail[0m the value
        bound  to the component with name the stamp of the method is increased
        by 1 (not being bound means zero).
  
  [1m[33m[22m[32msuccessmethod[0m[0m
        the  stamp of the method that succeeded, if one did. This component is
        only bound after successful completion.
  
  [1m[33m[22m[32mresult[0m[0m
        a  boolean  value  which is either [22m[32mtrue[0m or [22m[32mfail[0m depending on whether a
        successful  method  was  found  or the procedure gave up respectively.
        This  component is only bound after completion of the method selection
        procedure.
  
  [1m[33m[22m[32mtolerance[0m[0m
        the number of times all methods failed until one succeeded. See below.
  
  The  algorithm  used  by  [1m[34mCallMethods[0m is extremely simple: It sets a counter
  [22m[32mtolerance[0m  to  zero.  The  main  loop  starts at the beginning of the method
  database and runs through the methods in turn. Provided a method did not yet
  return  [22m[32mfalse[0m  and did not yet return [22m[32mfail[0m more than [22m[32mtolerance[0m times before,
  it  is  tried.  According to the value returned by the method, the following
  happens:
  
  [1m[33m[22m[32mfalse[0m[0m
        this is marked in the method selection record and the main loop starts
        again at the beginning of the method database.
  
  [1m[33m[22m[32mfail[0m[0m
        this  is  counted  in  the  method  selection record and the main loop
        starts again at the beginning of the method database.
  
  [1m[33m[22m[32mNotApplicable[0m[0m
        the main loop goes to the next method in the method database.
  
  [1m[33m[22m[32mtrue[0m[0m
        this  is  marked  in  the  method  selection  record and the procedure
        returns successfully.
  
  If  the  main  loop reaches the end of the method database without calling a
  method (because all methods have already failed or are not applicable), then
  the  counter  [22m[32mtolerance[0m  is  increased by one and everything starts all over
  again.  This  is repeated until [22m[32mtolerance[0m is greater than the [22m[32mlimit[0m which is
  the  second argument of [1m[34mCallMethods[0m. The last value of the [22m[32mtolerance[0m counter
  is returned in the component [22m[32mtolerance[0m of the method selection record.
  
  Note that the main loop starts again at the beginning of the method database
  after  each  failed  method call! However, this does not lead to an infinite
  loop,  because  the  failure is recorded in the method selection record such
  that the method is skipped until the [22m[32mtolerance[0m increases. Once the [22m[32mtolerance[0m
  has  been  increased  methods having returned [22m[32mfail[0m will be called again. The
  idea behind this approach is that even failed methods can collect additional
  information  about  the arguments changing them accordingly. This might give
  methods  that come earlier and were not applicable up to now the opportunity
  to begin working. Therefore one can install very good methods that depend on
  some  already  known knowledge which will only be acquired during the method
  selection procedure by other methods, with a high rank.
  
